const{Network:e,NetworkStatus:r}=require("@modular/dmnc-core"),{ModularTrustRoot:t,ModularSource:o,ModularVerifier:s}=require("@modular/smcc-core"),{ModularConfiguration:i}=require("@modular/config"),a=require("@modular/standard"),n=require("level");class l{constructor(r,t={}){if(1!==arguments.length&&2!==arguments.length)throw new RangeError("ModularPlatform constructor expects one or two arguments");if(!(r instanceof i))throw new TypeError("Config must be a valid ModularConfiguration object");if("object"!=typeof t)throw new TypeError("Options must be a valid options object");this.config=i.new(r),this.network=new e(r,t),this.network.platform=this,this.debugLogger=this.network.debugLogger,this.network.registerHandler("SOCIAL",this.socialHandler),this.db={},this.db.users=n("users"),this.db.posts=n("posts"),this.bigM=BigInt(this.network.network.M)}onReady(e){this.network.onReady(e)}initialize(){this.network.initialize()}useEndpoint(e){this.network.useEndpoint(e)}setCoverage(e){this.network.setCoverage(e)}static async standard(){const e=await a.config();return new l(e)}propagate(e){if(!Array.isArray(e.reach))throw new TypeError("Request.reach must be an array");const r=e.mod,t=new Set(e.reach),o=this.network.network.nodesCovering(r).map(e=>e.endpoint).filter(e=>!t.has(e)),s=o.concat(e.reach);e.reach=s;const i=[];return o.forEach(r=>{const t=this.network.peerQuery(r,[e]);i.push(t)}),Promise.allSettled(i)}startPropagation(e,r,t){const o=BigInt("0x"+Buffer.from(e,"base64").toString("hex"))%this.bigM;return this.propagate({layer:"SOCIAL",type:r,payload:t,mod:Number(o),reach:[],propagate:!0})}startSingleton(e,r,t){return new Promise((o,s)=>{const i=BigInt("0x"+Buffer.from(e,"base64").toString("hex")),a=Number(i%this.bigM),n=this.network.network.bestNodeCovering(a),l={layer:"SOCIAL",type:r,payload:t,mod:a};this.network.peerQuery(n.endpoint,[l]).then(e=>{o(e.results[0].result)}).catch(e=>{s(e)})})}socialHandler(r,t,o){return new Promise((s,i)=>{if(3!==arguments.length)throw new RangeError("ModularPlatform.socialHandler() expects exactly three arguments");if("string"!=typeof r)throw new TypeError("First argument to ModularPlatform.socialHandler() must be an string");if("object"!=typeof t)throw new TypeError("Second argument to ModularPlatform.socialHandler() must be an object");if(!(o instanceof e))throw new TypeError("Third argument to ModularPlatform.socialHandler() must be a Network");if("AHOY"!==r){if(!Number.isInteger(t.mod))throw new TypeError("Request.mod must be an integer");if(!0!==o.coverage.contains(t.mod))throw new RangeError("Node does not cover this mod. COVERAGE="+o.coverage.toString())}const a=["REGISTER","POST","FOLLOWS"];(function(e){switch(e){case"AHOY":return o.platform.ahoyHandler.bind(o.platform)();case"PROFILE":return o.platform.fetchProfile.bind(o.platform)(t);case"REGISTER":return o.platform.registerHandler.bind(o.platform)(t);case"POST":return o.platform.postHandler.bind(o.platform)(t);case"FOLLOWS":return o.platform.followsHandler.bind(o.platform)(t);default:throw new TypeError("SOCIAL handler cannot serve this request type")}})(r).then(e=>{!0===t.propagate&&a.includes(r)&&o.platform.propagate(t),s(e)}).catch(e=>{i(e)})})}ahoyHandler(){return new Promise((e,t)=>{this.network.status===r.READY?e("AYE AYE"):t(new Error("NO NO"))})}static validateTimestamp(e){if(!Number.isInteger(e))throw new TypeError("Timestamp must be an integer");if(!(e<=Date.now()))throw new RangeError("Timestamp must be in the past")}async followsHandler(e){const r=e.payload;if("string"!=typeof r.user)throw new TypeError("Incomplete request payload (user).");if(!Array.isArray(r.follows))throw new TypeError("Incomplete request payload (follows).");if(r.follows.length>4096)throw new RangeError("Follows list is too large.");if(r.follows.some(e=>e.length>44))throw new RangeError("Follows item is too large.");if("string"!=typeof r.sig)throw new TypeError("Incomplete request payload (signature).");l.validateTimestamp(r.timestamp);const o=BigInt("0x"+Buffer.from(r.user,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("User id does not match mod");const s=await this.loadUser(r.user);if(s.profile.FOLLOWS=t.SHA256(r.follows.join()),s.profile.LASTUPDATED=r.timestamp,!0!==await s.verifier.verifyUserProfileUpdate(r.sig,r.timestamp,s.profile))throw new Error("Could not verify profile update.");return s.signature=r.sig,s.follows=r.follows,await s.save(),"Saved follows."}async postHandler(e){const r=e.payload;if("string"!=typeof r.user)throw new TypeError("Incomplete request payload (user).");if("string"!=typeof r.body)throw new TypeError("Incomplete request payload (body).");if(r.body.length>1024)throw new RangeError("Post body is too large.");if("string"!=typeof r.prev)throw new TypeError("Incomplete request payload (prev).");if("string"!=typeof r.sig)throw new TypeError("Incomplete request payload (signature).");l.validateTimestamp(r.timestamp);const o=BigInt("0x"+Buffer.from(r.user,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("User id does not match mod");const s=await this.loadUser(r.user);if(s.profile.HEAD!==r.prev)throw new Error("Head does not match provided; RECENCY="+s.profile.LASTUPDATED);if(s.profile.HEAD=t.blockHash(r.timestamp+r.body,s.profile.HEAD),s.profile.LASTUPDATED=r.timestamp,!0!==await s.verifier.verifyUserProfileUpdate(r.sig,r.timestamp,s.profile))throw new Error("Could not verify profile update.");return s.signature=r.sig,s.posts.unshift({timestamp:r.timestamp,body:r.body,prev:r.prev}),await s.save(),"Saved post."}loadUser(e){return new Promise((r,t)=>{this.db.users.get(e,(o,i)=>{if(o)t(new Error("User does not exist."));else{const t=JSON.parse(i),o=new p(this);o.type="OTHER",o.key=t.key,o.signature=t.signature,o.follows=new Set(t.follows),s.loadUser(t.key).then(s=>{o.verifier=s,o.id=o.verifier.id;const i=[];Object.entries(t.profile).forEach(e=>{const[r,t]=e;i[r]=t}),o.profile=i,this.db.posts.get(e,(e,t)=>{o.posts=e?[]:JSON.parse(t),r(o)})})}})})}async registerHandler(e){const r=e.payload;if("string"!=typeof r.key)throw new TypeError("Incomplete request payload (key).");if("string"!=typeof r.id)throw new TypeError("Incomplete request payload (id).");if("string"!=typeof r.signature)throw new TypeError("Incomplete request payload (signature).");if("object"!=typeof r.profile)throw new TypeError("Incomplete request payload (profile).");if(!1!==await p.exists.bind(this)(r.id))throw new Error("Already registered.");l.validateTimestamp(r.timestamp);const t=await s.loadUser(r.key);if(t.id!==r.id)throw new Error("UID does not match key.");const o=BigInt("0x"+Buffer.from(t.id,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("UID does not match mod.");const i=[];if(Object.entries(r.profile).forEach(e=>{const[r,t]=e;i[r]=t}),!0!==await t.verifyUserProfileUpdate(r.signature,r.timestamp,i))throw new Error("Could not verify profile.");const a=new p(this);return a.key=r.key,a.id=t.id,a.profile=i,a.signature=r.signature,a.posts=[],a.follows=new Set,await a.save(),"Saved user."}fetchUser(e){const r=e.payload;return new Promise((t,o)=>{if("string"!=typeof r.id)throw new TypeError("User id must be a string");const s=BigInt("0x"+Buffer.from(r.id,"base64").toString("hex"))%this.bigM;if(Number(s)!==e.mod)throw new Error("User id does not match mod");this.db.users.get(r.id,(e,r)=>{e?o(new Error("User does not exist.")):t(JSON.parse(r))})})}fetchProfile(e){var r=256;Number.isInteger(e.maxPosts)&&e.maxPosts>0&&e.maxPosts<r&&(r=e.maxPosts);var t=4096;Number.isInteger(e.maxFollows)&&e.maxFollows>0&&e.maxFollows<t&&(t=e.maxFollows);const o=e.payload;return new Promise((s,i)=>{if("string"!=typeof o.id)throw new TypeError("User id must be a string");const a=BigInt("0x"+Buffer.from(o.id,"base64").toString("hex"))%this.bigM;if(Number(a)!==e.mod)throw new Error("User id does not match mod");this.loadUser(o.id).then(e=>{const o=e.posts.slice(0,r),i=e.follows.slice(0,t);s({profile:Object.assign({},e.profile),posts:o,follows:i,signature:e.signature,key:e.key})}).catch(e=>i(e))})}userList(e){return new Promise((e,r)=>{const t=[];this.db.users.createReadStream({limit:100}).on("data",e=>{t.push(JSON.parse(e.value))}).on("error",e=>{r(e)}).on("close",()=>{r(new Error("Stream error"))}).on("end",()=>{e(t)})})}async registerUser(e,r){const t=new p(this),s=await o.userRegistration(e,r);return t.id=s.source.id,t.type="ME",t.source=s.source,t.key=s.privateKeyArmored,t.profile=e,t.posts=[],t.follows=new Set,this.db.users.put("ME",t.id),t.signature=s.request.signature,t.save(),await this.startPropagation(t.id,"REGISTER",s.request),t}async getUserProfile(e,r=256,o=4096){const i=await this.startSingleton(e,"PROFILE",{id:e,maxPosts:r,maxFollows:o});if("OK"!==i.status)throw new Error("Could not find user.");const a=i.response,n=await s.loadUser(a.key);if(n.id!==e)throw new Error("User ID mismatch");const l=[];if(Object.entries(a.profile).forEach(e=>{const[r,t]=e;l[r]=t}),!0!==await n.verifyUserProfileUpdate(a.signature,l.LASTUPDATED,l))throw new Error("Signature could not be verified.");let p=l.HEAD;return a.posts.forEach(e=>{if(p!==t.blockHash(e.timestamp+e.body,e.prev))throw new Error("Posts could not be verified");e.verified=!0,p=e.prev}),a}}class p{constructor(e){this.platform=e}static exists(e){return new Promise((r,t)=>{this.db.users.get(e,(e,t)=>{r(!e)})})}save(){return new Promise((e,r)=>{this.platform.db.posts.put(this.id,JSON.stringify(this.posts.slice(0,256)),t=>{t&&r(t),this.platform.db.users.put(this.id,JSON.stringify({id:this.id,key:this.key,profile:Object.assign({},this.profile),signature:this.signature,follows:[...this.follows]}),t=>{t?r(t):e()})})})}async pushFollows(){if("ME"!==this.type)throw new TypeError("Cannot push follows from this account");const e=Date.now();this.profile.LASTUPDATED=e;const r=[...this.follows];this.profile.FOLLOWS=t.SHA256(r.join());const o=await this.source.userProfileUpdate(this.profile);return this.signature=o.signature,await this.platform.startPropagation(this.id,"FOLLOWS",{user:this.id,timestamp:e,follows:r,sig:{timestamp:o.timestamp,signature:o.signature}}),await this.save(),this.profile.FOLLOWS}async follow(e){if(this.follows.size>=4096)throw new RangeError("Maximum number of direct follows is 4096.");return this.follows.add(e),await this.pushFollows(),e}async unfollow(e){return this.follows.delete(e),await this.pushFollows(),e}async post(e){if("ME"!==this.type)throw new TypeError("Cannot post from this account");if("string"!=typeof e)throw new TypeError("Post body must be a string");if(e.length>1024)throw new RangeError("Post size is above maximum allowable");const r=this.profile.HEAD,o=Date.now();this.profile.HEAD=t.blockHash(o+e,r);const s=await this.source.userProfileUpdate(this.profile,o);return this.signature=s.signature,await this.platform.startPropagation(this.id,"POST",{user:this.id,timestamp:o,body:e,prev:r,sig:s.signature}),this.posts.unshift({timestamp:o,body:e,prev:r}),await this.save(),this.profile.HEAD}updateProfile(e){}verifySocial(e,r){}delete(){}block(e){}unblock(e){}static hidePost(e){}}module.exports.ModularPlatform=l,module.exports.ModularUser=p;