const{Network:e,NetworkStatus:r}=require("@modular/dmnc-core"),{ModularSource:t,ModularVerifier:o}=require("@modular/smcc-core"),{ModularConfiguration:s}=require("@modular/config"),i=require("@modular/standard"),a=require("level");class n{constructor(r,t={}){if(1!==arguments.length&&2!==arguments.length)throw new RangeError("ModularPlatform constructor expects one or two arguments");if(!(r instanceof s))throw new TypeError("Config must be a valid ModularConfiguration object");if("object"!=typeof t)throw new TypeError("Options must be a valid options object");this.config=s.new(r),this.network=new e(r,t),this.network.platform=this,this.debugLogger=this.network.debugLogger,this.network.registerHandler("SOCIAL",this.socialHandler),this.db={},this.db.users=a("users"),this.db.posts=a("posts"),this.bigM=BigInt(this.network.network.M)}onReady(e){this.network.onReady(e)}initialize(){this.network.initialize()}useEndpoint(e){this.network.useEndpoint(e),this.network.setCoverage("0%1")}static async standard(){const e=await i.config();return new n(e)}verifiedQuery(e,r,t){const o=BigInt("0x"+e)%this.bigM;return new Promise((e,s)=>{const i=[{layer:"SOCIAL",type:r,payload:t}],a=this.network.network.bestNodeCovering(Number(o));this.network.peerQuery(a.endpoint,i).then(r=>{e(r.results[0].result)}).catch(e=>{s(e)})})}socialHandler(r,t,o){if(3!==arguments.length)throw new RangeError("ModularPlatform.socialHandler() expects exactly three arguments");if("string"!=typeof r)throw new TypeError("First argument to ModularPlatform.socialHandler() must be an string");if("object"!=typeof t)throw new TypeError("Second argument to ModularPlatform.socialHandler() must be an object");if(!(o instanceof e))throw new TypeError("Third argument to ModularPlatform.socialHandler() must be a Network");switch(r){case"AHOY":return o.platform.ahoyHandler.bind(o.platform)(t.payload);case"POST":return o.platform.postHandler.bind(o.platform)(t.payload);case"REGISTER":return o.platform.registerHandler.bind(o.platform)(t.payload);case"USER":return o.platform.fetchUser.bind(o.platform)(t.payload);default:throw new TypeError("SOCIAL handler cannot serve this request type")}}ahoyHandler(e){return new Promise((e,t)=>{this.network.status===r.READY?e("AYE AYE"):t(new Error("NO NO"))})}postHandler(e){return new Promise((e,r)=>{e({dbPath:this.dbPath})})}static validateTimestamp(e){if(!Number.isInteger(e))throw new TypeError("Timestamp must be an integer");if(!(e<=Date.now()))throw new RangeError("Timestamp must be in the past");if(!(e>=Date.now()-6e4))throw new RangeError("Timestamp must be recent")}async registerHandler(e){if("string"!=typeof e.key)throw new TypeError("Incomplete request payload (key).");if("string"!=typeof e.profileUpdate.user)throw new TypeError("Incomplete request payload (user).");if("PROFILE"!==e.profileUpdate.type)throw new TypeError("Incomplete request payload (type).");if("string"!=typeof e.profileUpdate.body)throw new TypeError("Incomplete request payload (body).");if("string"!=typeof e.profileUpdate.signature)throw new TypeError("Incomplete request payload (signature).");if("object"!=typeof e.profile)throw new TypeError("Incomplete request payload (profile).");if(!1!==await l.exists.bind(this)(e.profileUpdate.user))throw new Error("Already registered.");n.validateTimestamp(e.profileUpdate.timestamp);const r=await o.loadUser(e.key);if(r.id!==e.profileUpdate.user)throw new Error("UID does not match key.");const t=[];if(Object.entries(e.profile).forEach(e=>{const[r,o]=e;t[r]=o}),!await r.verifyUserProfileUpdate(e.profileUpdate.signature,e.profileUpdate.timestamp,t))throw new Error("Could not verify profile.");const s=new l(this);return s.key=e.key,s.id=r.id,s.profile=Object.assign({},t),await s.save(),"Saved user."}fetchUser(e){return new Promise((r,t)=>{if("string"!=typeof e.id)throw new TypeError("User id must be a string");this.db.users.get(e.id,(e,o)=>{e&&t(new Error("User does not exist.")),r(JSON.parse(o))})})}async registerUser(e,r){const o=new l(this),s=await t.userRegistration(e,r);return o.type="ME",o.source=s.source,o.id=s.source.id,o.key=s.privateKeyArmored,o.profile=e,o.save(),this.db.users.put("ME",o.id),s.request.profile=Object.assign({},e),console.log(JSON.stringify(s.request)),this.verifiedQuery(o.id,"REGISTER",s.request),o}}class l{constructor(e){this.platform=e}static exists(e){return new Promise((r,t)=>{this.db.users.get(e,(e,t)=>{r(!e)})})}toString(){return JSON.stringify({id:this.id,key:this.key,profile:this.profile})}save(){return new Promise((e,r)=>{this.platform.db.users.put(this.id,this.toString(),t=>{t?r(t):e()})})}static login(e,r){}static other(e){}follow(e){}updateProfile(e){}verifySocial(e,r){}unfollow(e){}delete(){}block(e){}unblock(e){}static hidePost(e){}}module.exports.ModularPlatform=n,module.exports.ModularUser=l,module.exports.ModularPost=class{constructor(e){this.author=e}setType(e){}setTitle(e){}setLink(e){}setBody(e){}setParent(e){}addModerator(e){}upload(){}},module.exports.ModularMessage=class{constructor(e,r){this.sender=e,this.recipient=r}setBody(e){this.body=e}send(){}};