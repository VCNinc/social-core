const{Network:e,NetworkStatus:t}=require("@modular/dmnc-core"),{ModularSource:r}=require("@modular/smcc-core"),{ModularConfiguration:o}=require("@modular/config"),s=require("@modular/standard"),i=require("level");class n{constructor(t,r={}){if(1!==arguments.length&&2!==arguments.length)throw new RangeError("ModularPlatform constructor expects one or two arguments");if(!(t instanceof o))throw new TypeError("Config must be a valid ModularConfiguration object");if("object"!=typeof r)throw new TypeError("Options must be a valid options object");this.config=o.new(t),this.network=new e(t,r),this.network.platform=this,this.debugLogger=this.network.debugLogger,this.network.registerHandler("SOCIAL",this.socialHandler),this.db={},this.db.users=i("users"),this.db.posts=i("posts"),this.bigM=BigInt(this.network.network.M)}onReady(e){this.network.onReady(e)}initialize(){this.network.initialize()}useEndpoint(e){this.network.useEndpoint(e),this.network.setCoverage("0%1")}static async standard(){const e=await s.config();return new n(e)}verifiedQuery(e,t,r){const o=BigInt("0x"+e)%this.bigM;return new Promise((e,s)=>{const i=[{layer:"SOCIAL",type:t,payload:r}],n=this.network.network.bestNodeCovering(Number(o));this.network.peerQuery(n.endpoint,i).then(e=>{console.log(e)}).catch(e=>{console.error(e)})})}socialHandler(t,r,o){if(3!==arguments.length)throw new RangeError("ModularPlatform.socialHandler() expects exactly three arguments");if("string"!=typeof t)throw new TypeError("First argument to ModularPlatform.socialHandler() must be an string");if("object"!=typeof r)throw new TypeError("Second argument to ModularPlatform.socialHandler() must be an object");if(!(o instanceof e))throw new TypeError("Third argument to ModularPlatform.socialHandler() must be a Network");switch(t){case"AHOY":return o.platform.ahoyHandler.bind(o.platform)(r.payload);case"POST":return o.platform.postHandler.bind(o.platform)(r.payload);default:throw new TypeError("SOCIAL handler cannot serve this request type")}}ahoyHandler(e){return new Promise((e,r)=>{this.network.status===t.READY?e("AYE AYE"):r(new Error("NO NO"))})}postHandler(e){return new Promise((e,t)=>{e({dbPath:this.dbPath})})}async registerUser(e,t){const o=new a(this),s=await r.userRegistration(e,t);return o.type="ME",this.db.users.put("ME",o.id),o.source=s.source,o.id=s.source.id,o.key=s.privateKeyArmored,o.save(),this.verifiedQuery(o.id,"REGISTER",s.request),o}}class a{constructor(e){this.platform=e}toString(){return JSON.stringify({id:this.id,key:this.key})}save(){this.platform.db.users.put(this.id,this.toString())}static login(e,t){}static other(e){}updateProfile(e){}verifySocial(e,t){}delete(){}follow(e){}unfollow(e){}block(e){}static hidePost(e){}}module.exports.ModularPlatform=n,module.exports.ModularUser=a,module.exports.ModularPost=class{constructor(e){this.author=e}setType(e){}setTitle(e){}setLink(e){}setBody(e){}setParent(e){}addModerator(e){}upload(){}},module.exports.ModularMessage=class{constructor(e,t){this.sender=e,this.recipient=t}setBody(e){}send(){}};