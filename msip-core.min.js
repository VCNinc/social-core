const{Network:e,NetworkStatus:t}=require("@modular/dmnc-core"),{ModularTrustRoot:r,ModularSource:o,ModularVerifier:i}=require("@modular/smcc-core"),{ModularConfiguration:s}=require("@modular/config"),a=require("@modular/standard"),n=require("level");class p{constructor(t,r={}){if(1!==arguments.length&&2!==arguments.length)throw new RangeError("ModularPlatform constructor expects one or two arguments");if(!(t instanceof s))throw new TypeError("Config must be a valid ModularConfiguration object");if("object"!=typeof r)throw new TypeError("Options must be a valid options object");this.config=s.new(t),this.network=new e(t,r),this.network.platform=this,this.debugLogger=this.network.debugLogger,this.network.registerHandler("SOCIAL",this.socialHandler),this.db={},this.db.users=n("users"),this.db.posts=n("posts"),this.bigM=BigInt(this.network.network.M)}onReady(e){this.network.onReady(e)}initialize(){this.network.initialize()}useEndpoint(e){this.network.useEndpoint(e)}setCoverage(e){this.network.setCoverage(e)}static async standard(){const e=await a.config();return new p(e)}propagate(e){if(!Array.isArray(e.reach))throw new TypeError("Request.reach must be an array");const t=e.mod,r=new Set(e.reach),o=this.network.network.nodesCovering(t).map(e=>e.endpoint).filter(e=>!r.has(e)),i=o.concat(e.reach);e.reach=i;const s=[];return o.forEach(t=>{const r=this.network.peerQuery(t,[e]);s.push(r)}),Promise.allSettled(s)}startPropagation(e,t,r){const o=BigInt("0x"+Buffer.from(e,"base64").toString("hex"))%this.bigM;return this.propagate({layer:"SOCIAL",type:t,payload:r,mod:Number(o),reach:[],propagate:!0})}startSingleton(e,t,r){return new Promise((o,i)=>{const s=BigInt("0x"+Buffer.from(e,"base64").toString("hex")),a=Number(s%this.bigM),n=this.network.network.bestNodeCovering(a);this.network.peerQuery(n.endpoint,[{layer:"SOCIAL",type:t,payload:r,mod:a}]).then(e=>{o(e.results[0].result)}).catch(e=>{i(e)})})}socialHandler(t,r,o){return new Promise((i,s)=>{if(3!==arguments.length)throw new RangeError("ModularPlatform.socialHandler() expects exactly three arguments");if("string"!=typeof t)throw new TypeError("First argument to ModularPlatform.socialHandler() must be an string");if("object"!=typeof r)throw new TypeError("Second argument to ModularPlatform.socialHandler() must be an object");if(!(o instanceof e))throw new TypeError("Third argument to ModularPlatform.socialHandler() must be a Network");if("AHOY"!==t){if(!Number.isInteger(r.mod))throw new TypeError("Request.mod must be an integer");if(!0!==o.coverage.contains(r.mod))throw new RangeError("Node does not cover this mod. COVERAGE="+o.coverage.toString())}const a=["REGISTER","POST"];(function(e){switch(e){case"AHOY":return o.platform.ahoyHandler.bind(o.platform)();case"POSTS":return o.platform.fetchPosts.bind(o.platform)(r);case"REGISTER":return o.platform.registerHandler.bind(o.platform)(r);case"POST":return o.platform.postHandler.bind(o.platform)(r);default:throw new TypeError("SOCIAL handler cannot serve this request type")}})(t).then(e=>{!0===r.propagate&&a.includes(t)&&o.platform.propagate(r),i(e)}).catch(e=>{s(e)})})}ahoyHandler(){return new Promise((e,r)=>{this.network.status===t.READY?e("AYE AYE"):r(new Error("NO NO"))})}static validateTimestamp(e){if(!Number.isInteger(e))throw new TypeError("Timestamp must be an integer");if(!(e<=Date.now()))throw new RangeError("Timestamp must be in the past");if(!(e>=Date.now()-6e4))throw new RangeError("Timestamp must be recent")}async postHandler(e){const t=e.payload;if("string"!=typeof t.user)throw new TypeError("Incomplete request payload (user).");if("string"!=typeof t.body)throw new TypeError("Incomplete request payload (body).");if(t.body.length>1024)throw new RangeError("Post body is too large.");if("string"!=typeof t.prev)throw new TypeError("Incomplete request payload (prev).");if("string"!=typeof t.sig.signature)throw new TypeError("Incomplete request payload (signature).");p.validateTimestamp(t.timestamp),p.validateTimestamp(t.sig.timestamp);const o=BigInt("0x"+Buffer.from(t.user,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("User id does not match mod");const i=await this.loadUser(t.user);if(i.profile.HEAD!==t.prev)throw new Error("Head does not match provided; RECENCY="+i.profile.LASTUPDATED);if(i.profile.HEAD=r.blockHash(t.timestamp+t.body,i.profile.HEAD),i.profile.LASTUPDATED=t.timestamp,!0!==await i.verifier.verifyUserProfileUpdate(t.sig.signature,t.sig.timestamp,i.profile))throw new Error("Could not verify profile update.");return i.signature=t.sig.signature,i.sigtime=t.sig.timestamp,i.posts.unshift({timestamp:t.timestamp,body:t.body,prev:t.prev}),await i.save(),"Saved post."}loadUser(e){return new Promise((t,r)=>{this.db.users.get(e,(o,s)=>{if(o)r(new Error("User does not exist."));else{const r=JSON.parse(s),o=new d(this);o.type="OTHER",o.key=r.key,o.signature=r.signature,o.sigtime=r.sigtime,i.loadUser(r.key).then(i=>{o.verifier=i,o.id=o.verifier.id;const s=[];Object.entries(r.profile).forEach(e=>{const[t,r]=e;s[t]=r}),o.profile=s,this.db.posts.get(e,(e,r)=>{o.posts=e?[]:JSON.parse(r),t(o)})})}})})}async registerHandler(e){const t=e.payload;if("string"!=typeof t.key)throw new TypeError("Incomplete request payload (key).");if("string"!=typeof t.profileUpdate.user)throw new TypeError("Incomplete request payload (user).");if("PROFILE"!==t.profileUpdate.type)throw new TypeError("Incomplete request payload (type).");if("string"!=typeof t.profileUpdate.body)throw new TypeError("Incomplete request payload (body).");if("string"!=typeof t.profileUpdate.signature)throw new TypeError("Incomplete request payload (signature).");if("object"!=typeof t.profile)throw new TypeError("Incomplete request payload (profile).");if(!1!==await d.exists.bind(this)(t.profileUpdate.user))throw new Error("Already registered.");p.validateTimestamp(t.profileUpdate.timestamp);const r=await i.loadUser(t.key);if(r.id!==t.profileUpdate.user)throw new Error("UID does not match key.");const o=BigInt("0x"+Buffer.from(r.id,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("UID does not match mod.");const s=[];if(Object.entries(t.profile).forEach(e=>{const[t,r]=e;"LASTUPDATED"!==t&&(s[t]=r)}),!0!==await r.verifyUserProfileUpdate(t.profileUpdate.signature,t.profileUpdate.timestamp,s))throw new Error("Could not verify profile.");const a=new d(this);return a.key=t.key,a.id=r.id,a.profile=s,a.profile.LASTUPDATED=t.profileUpdate.timestamp,a.signature=t.profileUpdate.signature,a.sigtime=t.profileUpdate.timestamp,a.posts=[],await a.save(),"Saved user."}fetchUser(e){const t=e.payload;return new Promise((r,o)=>{if("string"!=typeof t.id)throw new TypeError("User id must be a string");const i=BigInt("0x"+Buffer.from(t.id,"base64").toString("hex"))%this.bigM;if(Number(i)!==e.mod)throw new Error("User id does not match mod");this.db.users.get(t.id,(e,t)=>{e?o(new Error("User does not exist.")):r(JSON.parse(t))})})}fetchPosts(e){var t=256;Number.isInteger(e.max)&&e.max>0&&e.max<t&&(t=e.max);const r=e.payload;return new Promise((o,i)=>{if("string"!=typeof r.id)throw new TypeError("User id must be a string");const s=BigInt("0x"+Buffer.from(r.id,"base64").toString("hex"))%this.bigM;if(Number(s)!==e.mod)throw new Error("User id does not match mod");this.loadUser(r.id).then(e=>{const r=e.posts.slice(0,t);o({profile:Object.assign({},e.profile),posts:r,signature:e.signature,sigtime:e.sigtime,key:e.key})}).catch(e=>i(e))})}userList(e){return new Promise((e,t)=>{const r=[];this.db.users.createReadStream({limit:100}).on("data",e=>{r.push(JSON.parse(e.value))}).on("error",e=>{t(e)}).on("close",()=>{t(new Error("Stream error"))}).on("end",()=>{e(r)})})}async registerUser(e,t){const i=new d(this),s=await o.userRegistration(e,t);return i.id=s.source.id,e.HEAD=r.SHA256(i.id),e.LASTUPDATED=s.request.profileUpdate.timestamp,i.type="ME",i.source=s.source,i.key=s.privateKeyArmored,i.profile=e,i.posts=[],this.db.users.put("ME",i.id),s.request.profile=Object.assign({},e),i.signature=s.request.profileUpdate.signature,i.sigtime=s.request.profileUpdate.timestamp,i.save(),await this.startPropagation(i.id,"REGISTER",s.request),i}async getUserPosts(e,t=256){const o=await this.startSingleton(e,"POSTS",{id:e,max:t});if("OK"!==o.status)throw new Error("Could not find user.");const s=o.response,a=await i.loadUser(s.key);if(a.id!==e)throw new Error("User ID mismatch");const n=[];if(Object.entries(s.profile).forEach(e=>{const[t,r]=e;n[t]=r}),!0!==await a.verifyUserProfileUpdate(s.signature,s.sigtime,n))throw new Error("Signature could not be verified.");let p=n.HEAD;return s.posts.forEach(e=>{if(p!==r.blockHash(e.timestamp+e.body,e.prev))throw new Error("Posts could not be verified");e.verified=!0,p=e.prev}),s}}class d{constructor(e){this.platform=e}static exists(e){return new Promise((t,r)=>{this.db.users.get(e,(e,r)=>{t(!e)})})}save(){return new Promise((e,t)=>{this.platform.db.posts.put(this.id,JSON.stringify(this.posts.slice(0,256)),r=>{r&&t(r),this.platform.db.users.put(this.id,JSON.stringify({id:this.id,key:this.key,profile:Object.assign({},this.profile),signature:this.signature,sigtime:this.sigtime}),r=>{r?t(r):e()})})})}async post(e){if("ME"!==this.type)throw new TypeError("Cannot post from this account");if("string"!=typeof e)throw new TypeError("Post body must be a string");if(e.length>1024)throw new RangeError("Post size is above maximum allowable");const t=this.profile.HEAD,o=Date.now();this.profile.HEAD=r.blockHash(o+e,t),this.profile.LASTUPDATED=o;const i=await this.source.userProfileUpdate(this.profile);return this.signature=i.signature,this.sigtime=i.timestamp,await this.platform.startPropagation(this.id,"POST",{user:this.id,timestamp:o,body:e,prev:t,sig:{timestamp:i.timestamp,signature:i.signature}}),this.posts.unshift({timestamp:o,body:e,prev:t}),await this.save(),this.profile.HEAD}static login(e,t){}static other(e){}follow(e){}updateProfile(e){}verifySocial(e,t){}unfollow(e){}delete(){}block(e){}unblock(e){}static hidePost(e){}}module.exports.ModularPlatform=p,module.exports.ModularUser=d;