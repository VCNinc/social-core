const{Network:e,NetworkStatus:t}=require("@modular/dmnc-core"),{ModularTrustRoot:r,ModularSource:o,ModularVerifier:s}=require("@modular/smcc-core"),{ModularConfiguration:i}=require("@modular/config"),n=require("@modular/standard"),a=require("level");class l{constructor(t,r={}){if(1!==arguments.length&&2!==arguments.length)throw new RangeError("ModularPlatform constructor expects one or two arguments");if(!(t instanceof i))throw new TypeError("Config must be a valid ModularConfiguration object");if("object"!=typeof r)throw new TypeError("Options must be a valid options object");this.config=i.new(t),this.network=new e(t,r),this.network.platform=this,this.debugLogger=this.network.debugLogger,this.network.registerHandler("SOCIAL",this.socialHandler),this.db={},this.db.users=a("db/users",{valueEncoding:"json"}),this.db.posts=a("db/posts",{valueEncoding:"json"}),this.bigM=BigInt(this.network.network.M)}onChange(e){this.network.onChange(e)}onReady(e){this.network.onReady(e)}initialize(){this.network.initialize()}useEndpoint(e){this.network.useEndpoint(e)}setCoverage(e){this.network.setCoverage(e)}static async standard(){const e=await n.config();return new l(e)}propagate(e){if(!Array.isArray(e.reach))throw new TypeError("Request.reach must be an array");const t=e.mod,r=new Set(e.reach),o=this.network.network.nodesCovering(t).map(e=>e.endpoint).filter(e=>!r.has(e)),s=o.concat(e.reach);e.reach=s;const i=[];return o.forEach(t=>{const r=this.network.queueRequest(()=>this.network.peerQuery(t,[e]));i.push(r)}),Promise.allSettled(i)}startPropagation(e,t,r){const o=BigInt("0x"+Buffer.from(e,"base64").toString("hex"))%this.bigM;return this.propagate({layer:"SOCIAL",type:t,payload:r,mod:Number(o),reach:[],propagate:!0})}startSingleton(e,t,r){return new Promise((o,s)=>{const i=BigInt("0x"+Buffer.from(e,"base64").toString("hex")),n=Number(i%this.bigM),a=this.network.network.bestNodeCovering(n);void 0===a&&s(new Error("Insufficient coverage to perform request."));const l={layer:"SOCIAL",type:t,payload:r,mod:n};this.network.queueRequest(()=>this.network.peerQuery(a.endpoint,[l])).then(e=>{o(e.results[0].result)}).catch(e=>{s(e)})})}socialHandler(t,r,o){return new Promise((s,i)=>{if(3!==arguments.length)throw new RangeError("ModularPlatform.socialHandler() expects exactly three arguments");if("string"!=typeof t)throw new TypeError("First argument to ModularPlatform.socialHandler() must be an string");if("object"!=typeof r)throw new TypeError("Second argument to ModularPlatform.socialHandler() must be an object");if(!(o instanceof e))throw new TypeError("Third argument to ModularPlatform.socialHandler() must be a Network");if("AHOY"!==t){if(!Number.isInteger(r.mod))throw new TypeError("Request.mod must be an integer");if(!0!==o.coverage.contains(r.mod))throw new RangeError("Node does not cover this mod. COVERAGE="+o.coverage.toString())}const n=["REGISTER","POST","FOLLOWS"];(function(e){switch(e){case"AHOY":return o.platform.ahoyHandler.bind(o.platform)();case"PROFILE":return o.platform.fetchProfile.bind(o.platform)(r);case"REGISTER":return o.platform.registerHandler.bind(o.platform)(r);case"POST":return o.platform.postHandler.bind(o.platform)(r);case"FOLLOWS":return o.platform.followsHandler.bind(o.platform)(r);default:throw new TypeError("SOCIAL handler cannot serve this request type")}})(t).then(e=>{!0===r.propagate&&n.includes(t)&&o.platform.propagate(r),s(e)}).catch(e=>{i(e)})})}ahoyHandler(){return new Promise((e,r)=>{this.network.status===t.READY?e("AYE AYE"):r(new Error("NO NO"))})}static validateTimestamp(e,t=null){if(!Number.isInteger(e))throw new TypeError("Timestamp must be an integer");if(!(e<=Date.now()+1e3))throw new RangeError("Timestamp must be in the past");if(null!==t&&!(e>=Date.now()-t))throw new RangeError("Timestamp must be recent")}async followsHandler(e){const t=e.payload;if("string"!=typeof t.user)throw new TypeError("Incomplete request payload (user).");if(!Array.isArray(t.follows))throw new TypeError("Incomplete request payload (follows).");if(t.follows.length>this.config.maxFollowCount)throw new RangeError("Follows list is too large.");if(t.follows.some(e=>e.length>44))throw new RangeError("Follows item is too large.");if("string"!=typeof t.signature)throw new TypeError("Incomplete request payload (signature).");l.validateTimestamp(t.timestamp);const o=BigInt("0x"+Buffer.from(t.user,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("User id does not match mod");const s=await this.loadUser(t.user);if(s.profile.FOLLOWS=r.SHA256(t.follows.join()),s.profile.LASTUPDATED=t.timestamp,!0!==await s.verifier.verifyUserProfileUpdate(t.signature,t.timestamp,s.profile))throw new Error("Could not verify profile update.");return s.signature=t.signature,s.follows=t.follows,await s.save(),"Saved follows."}async postHandler(e){const t=e.payload;if("string"!=typeof t.user)throw new TypeError("Incomplete request payload (user).");if("string"!=typeof t.body)throw new TypeError("Incomplete request payload (body).");if(t.body.length>this.config.maxPostLength)throw new RangeError("Post body is too large.");if("string"!=typeof t.prev)throw new TypeError("Incomplete request payload (prev).");if("string"!=typeof t.signature)throw new TypeError("Incomplete request payload (signature).");l.validateTimestamp(t.timestamp);const o=BigInt("0x"+Buffer.from(t.user,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("User id does not match mod");const s=await this.loadUser(t.user);if(s.profile.HEAD!==t.prev)throw new Error("Head does not match provided; RECENCY="+s.profile.LASTUPDATED);if(s.profile.HEAD=r.blockHash(t.timestamp+t.body,s.profile.HEAD),s.profile.LASTUPDATED=t.timestamp,!0!==await s.verifier.verifyUserProfileUpdate(t.signature,t.timestamp,s.profile))throw new Error("Could not verify profile update.");return s.signature=t.signature,s.posts.unshift({timestamp:t.timestamp,body:t.body,prev:t.prev}),await s.save(),"Saved post."}async userLogin(e,t){const r=await o.userLogin(e,t),s=r.id,i=await this.downloadUser(s);return i.key=e,i.source=r,i.type="ME",i.save(),i}async downloadUser(e){const t=await this.getUserProfile(e),r=new f(this);return r.type="OTHER",r.key=t.key,r.signature=t.signature,r.follows=new Set(t.follows),r.verifier=await s.loadUser(t.key),r.id=r.verifier.id,r.profile=[],Object.entries(t.profile).forEach(e=>{const[t,o]=e;r.profile[t]=o}),r.posts=t.posts,r}loadUser(e){return new Promise((t,r)=>{this.db.users.get(e,(o,i)=>{if(o)r(new Error("User does not exist."));else{const r=i,o=new f(this);o.type="OTHER",o.key=r.key,o.signature=r.signature,o.follows=new Set(r.follows),s.loadUser(r.key).then(s=>{o.verifier=s,o.id=o.verifier.id;const i=[];Object.entries(r.profile).forEach(e=>{const[t,r]=e;i[t]=r}),o.profile=i,this.db.posts.get(e,(e,r)=>{o.posts=e?[]:r,t(o)})})}})})}async registerHandler(e){const t=e.payload;if("string"!=typeof t.key)throw new TypeError("Incomplete request payload (key).");if("string"!=typeof t.id)throw new TypeError("Incomplete request payload (id).");if("string"!=typeof t.signature)throw new TypeError("Incomplete request payload (signature).");if("object"!=typeof t.profile)throw new TypeError("Incomplete request payload (profile).");if(!1!==await f.exists.bind(this)(t.id))throw new Error("Already registered.");l.validateTimestamp(t.timestamp);const r=await s.loadUser(t.key);if(r.id!==t.id)throw new Error("UID does not match key.");const o=BigInt("0x"+Buffer.from(r.id,"base64").toString("hex"))%this.bigM;if(Number(o)!==e.mod)throw new Error("UID does not match mod.");const i=[];if(Object.entries(t.profile).forEach(e=>{const[t,r]=e;i[t]=r}),JSON.stringify(Object.assign({},i)).length>this.config.maxProfileLength)throw new RangeError("Profile exceeded maximum allowable size.");if(!0!==await r.verifyUserProfileUpdate(t.signature,t.timestamp,i))throw new Error("Could not verify profile.");const n=new f(this);return n.key=t.key,n.id=r.id,n.profile=i,n.signature=t.signature,n.posts=[],n.follows=new Set,await n.save(),"Saved user."}fetchProfile(e){var t=this.config.maxPostCount;Number.isInteger(e.maxPosts)&&e.maxPosts>0&&e.maxPosts<t&&(t=e.maxPosts);const r=e.payload;return new Promise((o,s)=>{if("string"!=typeof r.id)throw new TypeError("User id must be a string");const i=BigInt("0x"+Buffer.from(r.id,"base64").toString("hex"))%this.bigM;if(Number(i)!==e.mod)throw new Error("User id does not match mod");this.loadUser(r.id).then(e=>{const s=e.posts,i={profile:Object.assign({},e.profile),posts:s.slice(0,t),signature:e.signature,key:e.key};!0===r.withFollows&&(i.follows=[...e.follows]),o(i)}).catch(e=>s(e))})}async registerUser(e,t){const r=new f(this),s=await o.userRegistration(e,t);return r.id=s.source.id,r.type="ME",r.source=s.source,r.key=s.privateKeyArmored,r.profile=e,r.posts=[],r.follows=new Set,this.db.users.put("ME",r.id),r.signature=s.request.signature,r.save(),await this.startPropagation(r.id,"REGISTER",s.request),r}async getUserProfile(e,t=this.config.maxPostCount,o=!0){const i=await this.startSingleton(e,"PROFILE",{id:e,maxPosts:t,withFollows:o});if("OK"!==i.status)throw new Error("Could not find user.");const n=i.response,a=await s.loadUser(n.key);if(a.id!==e)throw new Error("User ID mismatch");const l=[];if(Object.entries(n.profile).forEach(e=>{const[t,r]=e;l[t]=r}),!0!==await a.verifyUserProfileUpdate(n.signature,l.LASTUPDATED,l))throw new Error("Signature could not be verified.");let f=l.HEAD;if(n.posts.forEach(e=>{if(f!==r.blockHash(e.timestamp+e.body,e.prev))throw new Error("Posts could not be verified");e.verified=!0,f=e.prev}),o&&l.FOLLOWS!==r.SHA256(n.follows.join()))throw new TypeError("Cannot verify follows");return n}}class f{constructor(e){this.platform=e}async unlock(e){this.source=await o.userLogin(this.key,e),this.type="ME"}getMod(){if(void 0===this.mod){const e=BigInt("0x"+Buffer.from(this.id,"base64").toString("hex"))%this.platform.bigM;this.mod=Number(e)}return this.mod}getUrl(){return void 0===this.urlID&&(this.urlID=this.id.replace(/\+/g,"-").replace(/\//g,"_")),this.urlID}getSector(){return void 0===this.sector&&(this.sector=this.getMod()%this.platform.config.sectorMapSize),this.sector}getLogoSector(){return void 0===this.logoSector&&(this.logoSector=this.getMod()%this.platform.config.logoSectorMapSize),this.logoSector}getIconSector(){return void 0===this.iconSector&&(this.iconSector=this.getMod()%this.platform.config.iconSectorMapSize),this.iconSector}static exists(e){return new Promise((t,r)=>{this.db.users.get(e,(e,r)=>{t(!e)})})}save(){return new Promise((e,t)=>{this.platform.db.posts.put(this.id,this.posts.slice(0,this.platform.config.maxPostCount),r=>{r&&t(r),this.platform.db.users.put(this.id,{id:this.id,key:this.key,profile:Object.assign({},this.profile),signature:this.signature,follows:[...this.follows]},r=>{r?t(r):e()})})})}async pushFollows(){if("ME"!==this.type)throw new TypeError("Cannot push follows from this account");const e=Date.now();this.profile.LASTUPDATED=e;const t=[...this.follows];this.profile.FOLLOWS=r.SHA256(t.join());const o=await this.source.userProfileUpdate(this.profile,e);return this.signature=o.signature,await this.platform.startPropagation(this.id,"FOLLOWS",{user:this.id,timestamp:e,follows:t,signature:o.signature}),await this.save(),this.profile.FOLLOWS}async follow(e){if(this.follows.size>=this.platform.config.maxFollowCount)throw new RangeError("Maximum number of direct follows exceeded.");return this.follows.add(e),await this.pushFollows(),e}async unfollow(e){return this.follows.delete(e),await this.pushFollows(),e}async post(e){if("ME"!==this.type)throw new TypeError("Cannot post from this account");if("string"!=typeof e)throw new TypeError("Post body must be a string");if(e.length>this.platform.config.maxPostLength)throw new RangeError("Post size is above maximum allowable");const t=this.profile.HEAD,o=Date.now();this.profile.HEAD=r.blockHash(o+e,t);const s=await this.source.userProfileUpdate(this.profile,o);return this.signature=s.signature,await this.platform.startPropagation(this.id,"POST",{user:this.id,timestamp:o,body:e,prev:t,signature:s.signature}),this.posts.unshift({timestamp:o,body:e,prev:t}),await this.save(),this.profile.HEAD}getTimeline(e=this.follows,t=this.platform.config.maxPostCount){return new Promise((o,i)=>{const n=[],a=new Set(e);e.forEach(e=>{const t=BigInt("0x"+Buffer.from(e,"base64").toString("hex")),r=Number(t%this.platform.bigM);n.push({user:e,id:r})});const l=this.platform.network.network.minimalIDCoverageSet(n);if(l.uncovered.length>0)return i(new Error("Network did not cover all provided nodes."));const f=[];l.covered.forEach(e=>{const r=[];e.identifiers.forEach(e=>{r.push({layer:"SOCIAL",type:"PROFILE",payload:{id:e.user,max:t,withFollows:!1},mod:e.id})}),f.push(this.platform.network.queueRequest(()=>this.platform.network.peerQuery(e.node.endpoint,r)))}),Promise.all(f).then(e=>{(async()=>{const t=[];for(const o of e)for(const e of o.results){const o=e.request.payload.id;if(a.delete(o),"OK"!==e.result.status)throw new Error("Error loading user data.");const i=e.result.response,n=await s.loadUser(i.key);if(n.id!==o)throw new Error("User ID mismatch");const l=[];if(Object.entries(i.profile).forEach(e=>{const[t,r]=e;l[t]=r}),!0!==await n.verifyUserProfileUpdate(i.signature,l.LASTUPDATED,l))throw new Error("Signature could not be verified.");l.id=o;let f=l.HEAD;i.posts.forEach(e=>{if(f!==r.blockHash(e.timestamp+e.body,e.prev))throw new Error("Posts could not be verified");e.verified=!0,e.profile=l,t.push(e),f=e.prev})}a.size>0?i(new RangeError("Could not access all follows.")):o(t)})()}).catch(e=>{i(e)})})}updateProfile(e){}verifySocial(e,t){}delete(){}block(e){}unblock(e){}static hidePost(e){}}module.exports.ModularPlatform=l,module.exports.ModularUser=f,module.exports.ModularSocial=class{static rankChronological(e){return e.sort((e,t)=>t.timestamp-e.timestamp)}};